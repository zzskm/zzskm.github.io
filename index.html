<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pages Index</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 720px; margin: 40px auto; padding: 0 16px; }
    h1 { font-size: 24px; }
    h2 { font-size: 16px; margin-top: 20px; }
    ul { line-height: 1.8; padding-left: 18px; }
    a { text-decoration: none; }
    a:hover { text-decoration: underline; }
    .meta { color: #666; font-size: 12px; }
    .group { margin-bottom: 16px; }
  </style>
</head>
<body>
  <h1>웹 페이지 목록</h1>
  <p class="meta" id="meta">loading...</p>
  <div id="groups"></div>

  <script>
    const owner = "zzskm";
    const repo  = "zzskm.github.io";
    const branch = "main";

    // 여기서 원하는 폴더 추가.
    // "" = 루트
    const paths = ["", "numsprint", "yuc"]; // 예: ["", "docs", "vacations"]

    function makeApiUrl(path) {
      // path가 ""면 /contents/ 가 되고, "docs"면 /contents/docs
      const safePath = path ? path.replace(/^\/+|\/+$/g, "") : "";
      return `https://api.github.com/repos/${owner}/${repo}/contents/${safePath}?ref=${branch}`;
    }

    async function fetchHtmlInPath(path) {
      const api = makeApiUrl(path);
      const res = await fetch(api);
      if (!res.ok) throw new Error(`GitHub API error (${path || "root"}): ${res.status}`);

      const items = await res.json();
      if (!Array.isArray(items)) return []; // 폴더가 아닌 파일이면 배열 아님

      return items
        .filter(x => x.type === "file" && x.name.endsWith(".html"))
        // 루트의 index.html만 제외, 다른 폴더 index는 포함
        .filter(x => !(x.name.toLowerCase() === "index.html" && (path === "" || path === "/")))
        .map(x => ({
          name: x.name,
          path: path,
          href: path ? `${path.replace(/^\/+|\/+$/g, "")}/${x.name}` : x.name
        }));

    }

    async function run() {
      const metaEl = document.getElementById("meta");
      const groupsEl = document.getElementById("groups");

      try {
        const results = await Promise.allSettled(paths.map(p => fetchHtmlInPath(p)));

        // 성공한 것만 추출 + 그룹 유지
        const groups = results.map((r, i) => {
          const path = paths[i];
          if (r.status === "fulfilled") return { path, pages: r.value };
          return { path, pages: [], error: r.reason };
        });

        // 전체 카운트
        const total = groups.reduce((sum, g) => sum + g.pages.length, 0);
        metaEl.textContent = `${total} pages found in ${owner}/${repo}`;

        // 렌더링
        groupsEl.innerHTML = groups.map(g => {
          const title = g.path ? `/${g.path.replace(/^\/+|\/+$/g, "")}` : "(root)";
          if (g.error) {
            return `
              <div class="group">
                <h2>${title}</h2>
                <ul><li>로드 실패: ${g.error.message}</li></ul>
              </div>
            `;
          }
          const sorted = g.pages.sort((a,b) => a.name.localeCompare(b.name));
          const lis = sorted.length
            ? sorted.map(p => `<li><a href="${p.href}">${p.name}</a></li>`).join("")
            : "<li>없음.</li>";
          return `
            <div class="group">
              <h2>${title}</h2>
              <ul>${lis}</ul>
            </div>
          `;
        }).join("");

      } catch (e) {
        metaEl.textContent = "목록 로드 실패";
        groupsEl.innerHTML = `<ul><li>${e.message}</li></ul>`;
      }
    }

    run();
  </script>
</body>
</html>
